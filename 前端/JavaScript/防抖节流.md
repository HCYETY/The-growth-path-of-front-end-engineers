## 防抖节流
在前端开发中会遇到一些频繁的事件触发，比如：window 的 resize、scroll；mousedown、mousemove；keyup、keydown。为了解决这个问题，一般有两种解决方案：1.`debounce` 防抖；2.`throttle` 节流。

函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。
1. 防抖的原理：事件持续触发，但只有等事件停止触发后 n 秒才执行函数。防抖重在清零 clearTimeout(timer)。
- 防抖的应用场景
    - 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。
    - 表单验证
    - 按钮提交事件。
    - 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。
    - 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求。
    - 文本编辑器实时保存，当无任何更改操作一秒后进行保存。
2. 节流的原理：持续触发事件，每隔n秒，只执行一次事件。节流重在开关锁 timer = null。
- 节流的应用场景
    - 按钮点击事件
    - 拖拽事件
    - onScoll
    - 计算鼠标移动的距离(mousemove)
- 函数节流的实现
    - 时间戳：只要触发，就用 Date 获取现在的时间，与上一次的时间比较。
        ```js
        function rottle(func, wait) {
            var context, args;
            var previous = 0;

            return function() {
                var now = +new Date();
                context = arguments;
                if(now - previous > wait) {
                    func.apply(context, args);
                    previous = now;
                }
            }
        }
        ```
        如果时间差大于了规定的等待时间，就可以执行一次；目标函数执行以后，就更新 previous 值，确保它是“上一次”的时间。否则就等下一次触发时继续比较。
    - 定时器
        - 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。
        ```js
        function throttle(func, wait) {
            var timeout;
            var previous = 0;

            return function() {
                context = this;
                args = arguments;
                if(!timeout) {
                    timeout = setTimeout(function() {
                        timeout = null;
                        func.apply(context, args)
                    }, wait)
                }
            }
        }
        ```
    - 比较两个方法：
        - 时间戳事件会立刻执行，定时器事件会在 n 秒后第一次执行
        - 时间戳事件停止触发后没有办法再执行事件，定时器事件停止触发后依然会再执行一次事件
3. 区别
- 函数防抖的情况下，函数将一直推迟执行，造成不会被执行的效果；
- 函数节流的情况下，函数将每个 n 秒执行一次。
4. 实践：模拟实现防抖和节流函数
实现防抖函数
```js
function debounce(fn, wait, immediate) {
    let time, result;

    let debounced = function() {
        // 将 this 指向正确的对象
        let _this = this;
        // 提供事件对象 event
        let args = arguments;

        // 以新的事件的时间为准，更新时间，n秒后才执行
        if(time) {
            clearTimeout(time);
        }
        // 增加新需求：我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。
        // 立刻执行
        if(immediate) {
            let flag = !time;
            if(flag) {
                result = fn.apply(_this, args);
            }
            time = setTimeout(function() {
                time = null;
            }, wait)
        } else {
            time = setTimeout(function() {
                fn.apply(_this, args);
            }, wait);
        }
        // getUserAction 函数可能是有返回值的，所以要返回函数的执行结果
        return result;
    };

    // 另一个需求：希望有一个按钮，点击后，取消防抖，这样再去触发的时候，就可以又立刻执行
    debounced.cancel = function() {
        clearTimeout(time);
        time = null;
    };

    return debounced;
}
                
var count = 1;
var container = document.getElementById("container");
function getUserAction() {
    container.innerHTML = count++;
};
var setUserAction = debounce(getUserAction, 1000, true);
container.onmousemove = setUserAction;
document.getElementById("button").addEventListener('click', function() {
    setUserAction.cancel();
})
```
实现节流函数：时间戳和定时器的结合（可实现 有头有尾、有头无尾、无头有尾 三种形式）
```js
function throttle(fn, wait, options) {
    let _this, args;
    let time, previous = 0;
    if(!options) {
        options = {};
    }

    let throttled = function() {
        _this = this;
        args = arguments;
        let now = new Date().getTime();
        // 无头有尾的准备工作
        if(!previous && options.leading===false) {
            previous = now;
        }
        let remaining = wait - (now - previous);
        // 有头的代码：即时间戳
        // 如果没有剩余的时间了或者你改了系统时间
        if(remaining<=0 || remaining>wait) {
            if(time) {
                clearTimeout(time);
                time = null;  // 设置为null，让定时器可以启动
            }
            previous = now;  // 及时更新时间戳
            fn.apply(_this, args);
            // if(!time) context = args = null;
        } 
        // 有尾的代码：即定时器
        else if(!time && options.trailing!==false) {
            time = setTimeout(() => {
                previous = 0;
                time = null;
                fn.apply(_this, args);
                // if(!time) context = args = null;
            }, remaining);
        }
    };

    throttled.cancel = function() {
        clearTimeout(time);
        time = null;
        previous = 0;
    }

    return throttled;
}

var count = 1;
var container = document.getElementById("container");
function getUserAction() {
    container.innerHTML = count++;
};
// leading:false 表示禁用第一次执行
// trailing:false 表示禁用停止触发的回调
var setUserAction = throttle(getUserAction, 1000, {leading:false});
container.onmousemove = setUserAction;
document.getElementById("button").addEventListener('click', function() {
    setUserAction.cancel();
})
```