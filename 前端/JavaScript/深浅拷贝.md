## 深浅拷贝
### 浅拷贝
如果数组元素是基本类型，就会拷贝一份，互不影响；而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。（一种复制引用的拷贝方法） 
### 深拷贝
指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。
- 实现深拷贝需要考虑几个因素：
    - 传入的对象是使用对象字面量{}创建的对象还是由构造函数生成的对象
    - 如果对象是由构造函数创建出来的，那么是否要拷贝原型链上的属性
    - 如果要拷贝原型链上的属性，那么如果原型链上存在多个同名的属性，保留哪个
    - 处理循环引用的问题
- 实践：实现一个深拷贝函数
```js
// 原生js中递归函数拷贝
function deepCopy(obj) {
    // 定义一个变量接收新对象
    var newObj = null;

    if(obj instanceof Array) {
        newObj = [];
        // 复制法一
        for(let index in obj) {
            var prop = obj[index]; 
            if (prop == obj) {
                continue;
            }
            // callee, 该属性是一个指针，指向拥有这个 arguments 对象的函数,相当于deepCopy(),即递归调用自身;有利于降低代码的耦合度（如果更换函数名，也可正常递归，不受其他代码影响）
            newObj.push(arguments.callee(obj[index]));
            // newObj.push(deepCopy(obj[index]));
        }
        // 复制法二
        // obj.forEach(item => {
        //     newObj = arguments.callee(item);
        // });
    } else if(obj instanceof Object) {
        newObj = {};
        for(let index in obj) {
            newObj[index] = arguments.callee(obj[index]);
            // newObj[index] = deepCopy(obj[index]);
        }
    } else {
        newObj = obj;
    }            

    return newObj;

    // 该函数存在的问题：
    // 同名的属性会发生覆盖现象

    // 如果对象是由构造函数创建出来的，那么是否要拷贝原型链上的属性
    // 传入的对象是使用对象字面量{}创建的对象还是由构造函数生成的对象
}

let obj={
    abc:'123',
    def:[{a:1,b:2,c:3},{q:8,w:9}],
    qwe:{e: 4, f: 5}
};
let news = deepCopy(obj);   
console.log(news);
/* 复制法一console：                       复制法二console：  
{abc: "123" ,                             {abc: "123",
def: Array(2),                             def: {q: 8, w: 9},
    0: {a: 1, b: 2, c: 3}                  qwe: {e: 4, f: 5}}
    1: {q: 8, w: 9}
qwe: {e: 4, f: 5}}
*/

// // 实现jQuery中的extend函数进行拷贝
// function deepCopy(obj) {
//     if (obj && obj instanceof Object) {
//         var result = obj.constructor === Array ? [] : {};
//         for(let i in obj) {
//             // 避免相互引用造成死循环
//             var prop = obj[i]; 
//             if (prop == obj) {
//                 continue;
//             }
//             // hasOwnProperty(propertyName)方法 是用来检测属性是否为对象的自有属性，如果是，返回true，否者false; 参数propertyName指要检测的属性名；
//             if (obj.hasOwnProperty(i)) {
//                 result[i] = typeof obj[i] === 'object' ? deepCopy(obj[i]) : obj[i];
//             }
//         }
//     } else {
//         var result = obj;
//     }
    
//     return result;
// }

// let obj={
//     abc:'123',
//     def:[{a:1,b:2,c:3},{q:8,w:9}],
//     qwe:{e: 4, f: 5}
// };
// let news = deepCopy(obj);
// console.log(news);
```