<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
        // 1.原型链继承
        function Parent() {
            this.name = 'siyang';
        }
        Parent.prototype.getName = function() {
            console.log(this.name);
        }
        function child() {}
        child.prototype = new Parent();
        var son = new child();
        son.getName(); // siyang

        // 2.借用构造函数(经典继承)
        function Parent() {
            this.name = ['siyang'];
        }
        function child() {
            Parent.call(this);
        }
        var son = new child();
        son.name.push('hcy');
        console.log(son.name); // ["siyagn", "hcy"]

        // 3.组合继承（原型链继承和经典继承）
        function Parent(name) {
            this.name = name;
            this.color = ['blue'];
        }
        function child(name, age) {
            Parent.call(this, name);
            this.age = age;
        }
        child.prototype = new Parent();

        var son = new child('hcy','20');
        son.color.push('red');
        console.log(son.name); // hcy
        console.log(son.age); // 20
        console.log(son.color); // ["blue", "red"]
        
        var sister = new child('hg');
        console.log(sister.color); // ["blue"]

        // 4.原型式继承
        function Parent(o) {
            // 创建一个临时性的构造函数
            function F() {}
            // 将传入的对象作为这个构造函数的原型
            F.prototype = o;
            // 返回这个临时类型的一个新实例
            return new F();
        }
        var person = {
            name: "hcy",
            friends: ["et", "siyang"]
        }
        var another = Parent(person);
        console.log(another.name); // hcy
        another.friends.push('hg');

        var son = Parent(person);
        console.log(son.friends); // ["et", "siyang", "hg"]
        son.name = 'zbc';

        var sister = Parent(person);
        console.log(sister.name); // hcy

        // 5.寄生式继承
        function Parent(o) {
            function F() {}
            F.prototype = o;
            return new F();
        }
        function createAnother(original) {
            var clone = Parent(original);
            clone.sayHi = function() {
                alert("Hello World!");
            };
            return clone;
        }
        var person = {
            name:'siyang',
            friends:['hcy']
        }
        var another = createAnother(person);
        another.sayHi(); // Hello World!

       // 6.寄生组合式继承
        function obj(o) {
            function F() {}
            F.prototype = o;
            return new F();
        }
        function inheritPrototype(child, Parent) {
            // 创建超类型原型的一个副本
            var _prototype = obj(Parent.prototype);
            // 为创建的副本添加constructor属性，弥补因重写原型而失去的默认的constructor属性
            _prototype.constructor = child;
            // 将新创建的对象（即副本）赋值给子类型的原型
            child.prototype = _prototype;
        }

        function Parent(name) {
            this.name = name;
            this.colors = ["blue", "red"];
        }
        Parent.prototype.sayName = function() {
            console.log(this.name);
        };
        function child(name, age) {
            Parent.call(this, name);
            this.age = age;
        }
        inheritPrototype(child, Parent);
        child.prototype.sayAge = function() {
            console.log(this.age);
        };
        var sister = new child('siyang', '20');
        sister.sayAge(); // 20
        sister.sayName(); // siyang
        sister.colors.push('yellow');
        console.log(sister.colors); //  ["blue", "red", "yellow"]
    </script>
</body>
</html>