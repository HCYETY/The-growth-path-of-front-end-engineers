## 基本数据类型
常见的五种基本数据类型是：Undifined、Null、Boolean、Number和String。后来ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型。
> Symbol 的使用可参考：[ECMAScript 6 入门 之 Symbol](https://es6.ruanyifeng.com/#docs/symbol)   
1. 基本数据类型的值是不可变的，任何方法都无法改变一个基本类型的值，比如一个字符串：
```js
var name = "change";
name.substr(); // hang
console.log(name); // change

var s = "hello";
s.toUpperCase(); // HELLO
console.log(s); // hello
```
> [JavaScript substr() 方法](https://www.w3school.com.cn/jsref/jsref_substr.asp)      

通过这两个例子，我们会发现原先定义的变量name的值始终没有发生改变，而调用substr()和toUpperCase()方法后返回的是一个新的字符串，跟原先定义的变量name并没有关系

或许有人会有以下的疑问：
```js
var name = "change";
name = "change1";
console.log(name); // change1
```
- 这样看起来name的值“改变了”，其实，var name = “change”，这里的基础类型是string，也就是“change”,这里的“change”是不可以改变的，**name只是指向“change”的一个指针，指针的指向可以改变，所以你可以name = “change1”.此时name指向了“change1”**，同理，这里的“change1”同样不可以改变
- 也就是说这里你认为的改变只是“指针的指向改变”，这里的基础类型指的是“change”，而不是name，要区分清楚

2. 基本数据类型不可以添加属性和方法
```js
var p = "change";
p.age = 29;
p.method = function(){console.log(name)};
console.log(p.age); // undefined
console.log(p.method); // undefined
```
通过上面的代码，我们知道不能给基本类型添加属性和方法，也再次说明基本类型是不可变的

3. 基本数据类型的赋值是简单赋值
如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上
```js
var a = 10;
var b = a;
a++;
console.log(a) // 11
console.log(b) // 10
```
上面的代码中， a 中保存的值是10。当使用 a 的值来初始化 b 时， b 中也保存了值 10 。但 b 中的 10 和 a 中的 10 是完全独立的。 b 中的值只是 a 中值的一个副本。所以这两个变量可以参与任何操作而不会相互影响。

4. 基本数据类型的比较是值的比较
```js
var a = 1;
var b = true;
console.log(a == b); // true
console.log(a == b); // false
```
上面 a 和 b 的数据类型不同，但是也可以进行值的比较，这是因为在比较之前，自动进行了数据类型的 隐式转换。
== : 只进行值的比较；=== : 不仅进行值的比较，还要进行数据类型的比较

5. 基本数据类型是存放在栈区的
假如有以下几个基本类型的变量：
```js
var name = "jozo";
var city = "guangzhou";
var age = 22;
```
那么它的存储结构如下所示：
|栈区A|栈区A|
|:--:|:--:|
|name|jozo|
|city|guangzhou|
|age|22|
栈区包括了变量的标识符和变量的值

---

## 引用类型
除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等。
1. 引用类型的值是可以改变的
2. 引用类型可以添加属性和方法
3. 引用类型的赋值是对象引用
```js
var a = {};
var b = a;
a.name = "change";
console.log(a.name); // change
console.log(b.name); // change
b.age = 29;
console.log(a.age); // 29
console.log(b.age); // 29
```
当 a 向 b 赋值引用类型的值时，同样也会将储存在 a 中的对象的值复制一份，并放到为 b 分配的空间中。此时引用类型保存在 b 中的是对象在堆内存中的地址。所以，与基本数据类型的简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。那么赋值操作后，两个变量都保存了同一个对象地址，而这两个地址指向了同一个对象。因此，改变其中任何一个变量，都会互相影响。
他们的关系如下图：
![图片来源网络](https://xtclter10y.feishu.cn/space/api/box/stream/download/all/boxcnnEyux3P2AX3qfpzngOtvpd?mount_node_token=bmncni3YGVZyl7N6dfQqkK3KTwt&mount_point=mindnote_image)
- 因此，引用类型的赋值其实是对象保存在栈区地址指针的赋值，所以两个变量指向同一个对象，任何的操作都会互相影响。


4. 引用类型的比较是引用的比较
```js
var person1 = {};
var person2 = {};
console.log(person1 == person2); // false
```
为什么两个对象看起来一摸一样，但是却不相等呢？
- 因为引用类型的比较是引用的比较，换句话说，就是比较两个对象保存在栈区的指向堆内存的地址是否相同，此时，虽然p1和p2看起来都是一个”{}”，但是他们保存在栈区中的指向堆内存的地址却是不同的，所以两个对象不相等


5. 引用类型是同时保存在栈区和堆区中的   
引用类型的存储需要在内存的栈区和堆区共同完成，栈区保存变量标识符和指向堆内存的地址
假如有以下几个对象：
```js
var person1 = {name:"change1"};
var person2 = {name:"change2"};
var person3 = {name:"change3"};
```
则这三个对象在内存中保存的情况如下图：
![图片来源网络](https://xtclter10y.feishu.cn/space/api/box/stream/download/all/boxcnMKzXynix7GJDbuzo3GuAMh?mount_node_token=bmncni3YGVZyl7N6dfQqkK3KTwt&mount_point=mindnote_image)

---

## 类型转换
### 显式数据类型转化
ES6 前，JavaScript 共有六种数据类型：Undefined、Null、Boolean、Number、String、Object。
1. 原始值转布尔   
我们使用 Boolean 函数将类型转换成布尔类型，在 JavaScript 中，只有 6 种值可以被转换成 false，其他都会被转换成 true。
```js
// 当 Boolean 函数不传任何参数时，会返回 false。 
console.log(Boolean()) // false
console.log(Boolean(false)) // false 
console.log(Boolean(undefined)) // false 
console.log(Boolean(null)) // false 
console.log(Boolean(+0)) // false 
console.log(Boolean(-0)) // false 
console.log(Boolean(NaN)) // false 
console.log(Boolean("")) // false
```


2. 原始值转数字   
我们可以使用 Number 函数将类型转换成数字类型。如果 Number 函数不传参数，返回 +0；如果有参数，隐式调用 ToNumber(value)，ToNumber 则直接给了一个对应的结果表，表如下。但如果参数无法被转换为数字，则返回 NaN。

|参数类型|结果|
|:--:|:--:|
|Undefined|NaN|
|Null|+0|
|Boolean|如果参数是true，返回1.参数为false，返回+0|
|Number|返回与之相等的值|
|String|这段比较复杂，看例子|
```js
// 不传参
console.log(Number()) // +0 
// 传参
- Undefined
console.log(Number(undefined)) // NaN 
- Null
console.log(Number(null)) // +0 
- Boolean
console.log(Number(true)) // 1 
console.log(Number(false)) // +0 
- String
console.log(Number("123")) // 123 
console.log(Number("-123")) // -123 
console.log(Number("1.2")) // 1.2 
console.log(Number("000123")) // 123 
console.log(Number("-000123")) // -123 
console.log(Number("0x11")) // 17 
console.log(Number("")) // 0 
console.log(Number(" ")) // 0 
console.log(Number("123 123")) // NaN 
console.log(Number("foo")) // NaN 
console.log(Number("100a")) // NaN
```
如果通过 Number 转换函数传入一个字符串，它会试图将其转换成一个整数或浮点数，而且会忽略所有前导的 0，如果有一个字符不是数字，结果都会返回 NaN。鉴于这种严格的判断，我们一般还会使用更加灵活的 parseInt 和 parseFloat 进行转换。
- parseInt 只解析整数。如果字符串前缀是 "0x" 或者"0X"，会将其解释为十六进制数。
```js
console.log(parseInt("0xFF")) // 255 
console.log(parseInt("0.1")) // 0
```
- parseFloat 则可以解析整数和浮点数。
```js
console.log(parseFloat("3.14 abc")) // 3.14 
console.log(parseFloat(".1")) // 0.1 
```
- parseInt 和 parseFloat 都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回 NaN：
```js
console.log(parseInt("3 abc")) // 3 
console.log(parseInt("-12.34")) // -12 
```

3. 原始值转字符串   
我们使用 String 函数将类型转换成字符串类型。如果 String 函数不传参数，返回空字符串，如果有参数，隐式调用 ToString(value)。而 ToString 也给了一个对应的结果表，表如图：

|参数类型|结果|
|:--:|:--:|
|Undefined|"undefined"|
|Null|"null"|
|Bolean|如果参数是true，返回true。参数为false，返回false|
|Number|又是比较复杂，可以看例子|
|String|返回与之相等的值|
```js
// 不传参
console.log(String()) // 空字符串 
// 传参
- Undefined
console.log(String(undefined)) // undefined 
- Null
console.log(String(null)) // null 
- Boolean
console.log(String(true)) // true 
console.log(String(false)) // false 
- Number
console.log(String(0)) // 0 
console.log(String(-0)) // 0 
console.log(String(NaN)) // NaN 
console.log(String(Infinity)) // Infinity 
console.log(String(-Infinity)) // -Infinity 
console.log(String(1)) // 1
```

4. 原始值转对象   
原始值通过调用 String()、Number() 或者 Boolean() 构造函数，转换为它们各自的包装对象，（null 和 undefined 属于例外，当将它们用在期望是一个对象的地方都会造成一个类型错误 (TypeError) 异常，而不会执行正常的转换）。
```js
var b = new Number(a);  
console.log(typeof b); // object
```

6. 对象转布尔值   
所有对象(包括数组和函数)都转换为 true，对于包装对象也是这样。
```js
console.log(Boolean(new Boolean(false))) // true
```

7. 对象转字符串和数字   
对象到字符串 和 对象到数字 的转换都是通过调用待转换对象的一个方法来完成的。而 JavaScript 对象有两个不同的方法来执行转换，一个是 toString，一个是 valueOf。注意这个跟上面所说的 ToString 和 ToNumber 是不同的，这两个方法是真实暴露出来的方法。
- 当调用对象的 toString 方法时，其实调用的是 Object.prototype 上的 toString 方法。
    - 然而 JavaScript 下的很多类根据各自的特点，定义了更多版本的 toString 方法。例如：
    数组的 toString 方法将每个数组元素转换成一个字符串，并在元素之间添加逗号后合并成结果字符串。
    ```js
    console.log([].toString()) // "" 
    console.log([0].toString()) // 0
    console.log([1, 2, 3].toString()) // 1,2,3 
    ```
    - 函数的 toString 方法返回函数本身
    ```js
    console.log(({}).toString()) // [object Object]
    console.log((function(){var a = 1;}).toString()) // function (){var a = 1;} 
    ```
    - 日期的 toString 方法返回一个可读的日期和时间字符串。
    ```js
    var date = new Date(2010, 0, 1);
    console.log(date.toString()) // Fri Jan 01 2010 00:00:00 GMT+0800 (CST)
    ```
    - RegExp 的 toString 方法返回一个表示正则表达式直接量的字符串。
    ```js
    console.log((/\d+/g).toString()) // /\d+/g
    ```
- 而另一个转换对象的函数是 valueOf，表示对象的原始值。默认的 valueOf 方法返回这个对象本身，数组、函数、正则简单的继承了这个默认方法，也会返回对象本身。日期是一个例外，它会返回它的一个内容表示: 1970 年 1 月 1 日以来的毫秒数。
```js
var date = new Date(2017, 4, 21);
console.log(date.valueOf()) // 1495296000000
```

8. 对象转字符串   
对象到字符串是如何转换的，其实就是 ToString 方法的对应表，只是这次我们加上 Object 的转换规则：   

|参数类型|结果|
|:--:|:--|
|Object|1.primValue = ToPrimitive(input, String)<br>2.返回ToString(primValue)|

所谓的 ToPrimitive 方法，其实就是输入一个值，然后返回一个一定是基本类型的值。   
- 函数语法表示如右：ToPrimitive(input[, PreferredType])
    - 第一个参数是 input，表示要处理的输入值。
        - 如果传入的 input 是 Undefined、Null、Boolean、Number、String 类型，直接返回该值。
    - 第二个参数是 PreferredType，非必填，表示希望转换成的类型，有两个值可以选，Number 或者 String。
        - 当不传入 PreferredType 时，如果 input 是日期类型，相当于传入 String，否则，都相当于传入 Number。


- 如果是 ToPrimitive(obj, Number)，处理步骤如下：   
    - 如果 obj 为 基本类型，直接返回
    - 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。
    - 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。
    - 否则，JavaScript 抛出一个类型错误异常。

- 如果是 ToPrimitive(obj, String)，处理步骤如下：   
    - 如果 obj为 基本类型，直接返回
    - 否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。
    - 否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。
    - 否则，JavaScript 抛出一个类型错误异常。

初次总结：当我们用 String 方法转化一个值的时候，如果是基本类型，就参照 “原始值转字符” 这一节的对应表，如果不是基本类型，我们会将调用一个 ToPrimitive 方法，将其转为基本类型，然后再参照“原始值转字符” 这一节的对应表进行转换。

最终总结：对象转字符串(就是 Number() 函数)可以概括为：
- 如果对象具有 toString 方法，则调用这个方法。如果他返回一个原始值，JavaScript 将这个值转换为字符串，并返回这个字符串结果。
- 如果对象没有 toString 方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf 方法。如果存在这个方法，则 JavaScript 调用它。如果返回值是原始值，JavaScript 将这个值转换为字符串，并返回这个字符串的结果。
- 否则，JavaScript 无法从 toString 或者 valueOf 获得一个原始值，这时它将抛出一个类型错误异常。

9. 对象转数字   
其实，从对象到数字的转换也是一样：

|参数类型|结果|
|:--:|:--| 
|Object|1.primValue = ToPrimitive(input, Number)<br>2.返回ToNumber(primValue)| 

**虽然转换成基本值都会使用 ToPrimitive 方法，但传参有不同，最后的处理也有不同 -> 转字符串调用的是 ToString，转数字调用 ToNumber。**

- 对象转数字的过程中，JavaScript 做了同样的事情，只是它会首先尝试 valueOf 方法。   
    - 如果对象具有 valueOf 方法，且返回一个原始值，则 JavaScript 将这个原始值转换为数字并返回这个数字。
    - 否则，如果对象具有 toString 方法，且返回一个原始值，则 JavaScript 将其转换并返回。
    - 否则，JavaScript 抛出一个类型错误异常。
```js
console.log(Number({})) // NaN
console.log(Number({a : 1})) // NaN
console.log(Number([])) // 0
console.log(Number([0])) // 0
console.log(Number([1, 2, 3])) // NaN
console.log(Number(function(){var a = 1;})) // NaN
console.log(Number(/\d+/g)) // NaN
console.log(Number(new Date(2010, 0, 1))) // 1262275200000
console.log(Number(new Error('a'))) // NaN
```
- 注意，在以上代码块中，[] 和 [0] 都返回了 0，而 [1, 2, 3] 却返回了一个 NaN。我们分析一下原因：
    - 当我们 Number([]) 的时候，先调用 [] 的 valueOf 方法，此时返回 []，因为返回了一个对象而不是原始值，所以又调用了 toString 方法，此时返回一个空字符串，接下来调用 ToNumber 这个规范上的方法，参照对应表，转换为 0, 所以最后的结果为 0。
    - 而当我们 Number([1, 2, 3]) 的时候，先调用 [1, 2, 3] 的 valueOf 方法，此时返回 [1, 2, 3]，再调用 toString 方法，此时返回 1,2,3，接下来调用 ToNumber，参照对应表，因为无法转换为数字，所以最后的结果为 NaN。

### 隐式数据类型转化
#### 一元操作符 +
当 + 运算符作为一元操作符的时候，会调用 ToNumber 处理该值，既然是调用 ToNumber 方法，当输入的值是对象的时候，先调用 ToPrimitive(input, Number) 方法，例子：
```js
console.log(+[]);
    // [] 调用 valueOf 方法，返回一个空数组；
    // 因为不是原始值，继续调用 toString 方法，返回 ""；
    // 得到返回值后，然后再调用 ToNumber 方法，"" 对应的返回值是 0，所以最终返回 0。
console.log(+['1']); // 1 
console.log(+['1', '2', '3']); // NaN 
console.log(+{}); // NaN
```

#### 二元操作符 +
当计算 value1 + value2时：
```js
lprim = ToPrimitive(value1)
rprim = ToPrimitive(value2)
```
- 如果 lprim 是字符串或者 rprim 是字符串，那么返回 ToString(lprim) 和 ToString(rprim)的拼接结果   
- 返回 ToNumber(lprim) 和 ToNumber(rprim)的运算结果

1.Null 与数字
```js
console.log(null + 1);
```
- lprim = ToPrimitive(null) 因为null是基本类型，直接返回，所以 lprim = null
- rprim = ToPrimitive(1) 因为 1 是基本类型，直接返回，所以 rprim = 1
- lprim 和 rprim 都不是字符串
- 返回 ToNumber(null) 和 ToNumber(1) 的运算结果：ToNumber(null) 的结果为0，ToNumber(1) 的结果为 1。所以，null + 1 相当于 0 + 1，最终的结果为数字 1。

2.数组与数组
```js
console.log([] + []);
```
- lprim = ToPrimitive([])，[]是数组，相当于ToPrimitive([], Number)，先调用valueOf方法，返回对象本身，因为不是原始值，调用toString方法，返回空字符串""
- rprim类似。
- lprim和rprim都是字符串，执行拼接操作：[] + []相当于 "" + ""，最终的结果是空字符串""。

3.数组与对象
```js
// 两者结果一致 
console.log([] + {});   
console.log({} + []);
```
- lprim = ToPrimitive([])，lprim = ""
- rprim = ToPrimitive({})，相当于调用 ToPrimitive({}, Number)，先调用 valueOf 方法，返回对象本身，因为不是原始值，调用 toString 方法，返回 "[object Object]"
- lprim 和 rprim 都是字符串，执行拼接操作：[] + {} 相当于 "" + "[object Object]"，最终的结果是 "[object Object]"。
```js
console.log(1 + true); // 2 
console.log({} + {}); // "[object Object][object Object]" 
console.log(new Date(2017, 04, 21) + 1) // "Sun May 21 2017 00:00:00 GMT+0800 (CST)1"
```

#### == 相等
1. null和undefined
```js
console.log(null == undefined);
    规则2）x是null并且y是undefined，返回true
    规则3）x是undefined并且y是null，返回true
    // 所以例子的结果自然为 true。
```

2. 字符串与数字
```js
console.log('1' == 1);
    规则4）x是数字，y是字符串，判断x == ToNumber(y)
    规则5）x是字符串，y是数字，判断ToNumber(x) == y
    // 都先转换成数字后再进行比较，所以例子的结果为true。
```

3. 布尔值和其他类型
```js
console.log(true == '2')
    规则6）x是布尔值，判断ToNumber(x) == y
    规则7）y是布尔值，判断x ==ToNumber(y)
    // 当一方出现布尔值的时候，就会对这一方的值进行ToNumber处理，也就是说true会被转化成1，true == '2' 就相当于 1 == '2' 就相当于 1 == 2，结果自然是 false。
        // 所以当一方是布尔值的时候，会对布尔值进行转换，因为这种特性，所以尽量少使用 xx == true 和 xx == false 的写法。
```

4. 对象与非对象
```js
console.log( 42 == ['42'])
    规则8）x是字符串或者数字，y是对象，判断x == ToPrimitive(y)
    规则9）x是对象，y不是字符串或者数字，判断ToPrimitive(x) == y
    // 以这个例子为例，会使用 ToPrimitive 处理 ['42']，调用valueOf，返回对象本身，再调用 toString，返回 '42'，所以42 == ['42'] 相当于 42 == '42' 相当于42 == 42，结果为 true。
```

5.其他：一概返回 false
再多举几个例子进行分析：
```js
console.log(false == undefined)
    // false == undefined 相当于 0 == undefined 不符合上面的情形，执行最后一步 返回 false

console.log(false == [])
    // false == [] 相当于 0 == [] 相当于 0 == '' 相当于 0 == 0，结果返回 true

console.log([] == ![])
    // 首先会执行 ![] 操作，转换成 false，相当于 [] == false 相当于 [] == 0 相当于 '' == 0 相当于 0 == 0，结果返回 true
```

最后再举一些会让人踩坑的例子：
```js
console.log(false == "0")
console.log(false == 0)
console.log(false == "")

console.log("" == 0)
console.log("" == [])

console.log([] == 0)

console.log("" == [null])
console.log(0 == "\n")
console.log([] == 0)

// 以上均返回 true
```

---

## 浮点数精度 （0.1 + 0.2 !== 0.3）
### 浮点数的存储
**一个浮点数 (Value) 可以这样表示：Value = sign * exponent * fraction**
- 比如 -1020，用科学计数法表示就是:-1 * 10^3 * 1.02
    sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02
- 对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说，可以表示为：1 * 2^-4 * 1.1001100110011……
    - 其中 sign 就是 1，exponent 就是 2^-4，fraction 就是 1.1001100110011……

**而当只做二进制科学计数法的表示时，这个 Value 的表示可以再具体一点变成：V = (-1)^S * (1 + Fraction) * 2^E。**
- (-1)^S 表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。
- 再看 (1 + Fraction)，这是因为所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。
- 最后再看 2^E。如果是 1020.75，对应二进制数就是 1111111100.11，对应二进制科学计数法就是 1 * 1.11111110011 * 2^9，E 的值就是 9；而如果是 0.1 ，对应二进制是 1 * 1.1001100110011…… * 2^-4， E 的值就是 -4。也就是说，E 既可能是负数，又可能是正数。

**IEEE754 给出了标准：用 1 位存储 S（0 表示正数，1 表示负数），用 11 位存储 E + bias，用 52 位存储 Fraction。**

### 浮点数的运算
**一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。**
- 首先是对阶，所谓对阶，就是把阶码调整为相同。
    - 比如 0.1 是 1.1001100110011…… * 2^-4，阶码是 -4，
    - 而 0.2 就是 1.10011001100110...* 2^-3，阶码是 -3；
    - 两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… * 2^-3

- 接下来是尾数计算：
    - &nbsp;&nbsp;0.1100110011001100110011001100110011001100110011001101 +1.1001100110011001100110011001100110011001100110011010—————————————————————————————— 10.0110011001100110011001100110011001100110011001100111   
    - 我们得到结果为：10.0110011001100110011001100110011001100110011001100111 * 2^-3
- 将这个结果处理一下，即结果规格化：
    - 变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2，括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。

-  再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入。
    - 因为我们要把括号里的 1 丢了，所以这里会进一，结果变成1.0011001100110011001100110011001100110011001100110100 * 2^-2

- 本来还有一个溢出判断，因为这里不涉及，就不讲了。

所以最终的结果存成 64 位就是0 01111111101 0011001100110011001100110011001100110011001100110100，   
将它转换为10进制数就得到 0.30000000000000004440892098500626。   
因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3

### 其他
```js
// 十进制转二进制 
parseFloat(0.1).toString(2); 
=> "0.0001100110011001100110011001100110011001100110011001101" 

// 二进制转十进制 
parseInt(1100100,2) 
=> 100 

// 以指定的精度返回该数值对象的字符串表示 
(0.1 + 0.2).toPrecision(21) 
=> "0.300000000000000044409" 
(0.3).toPrecision(21) 
=> "0.299999999999999988898"
```

---

## var let const 区别使用
### var 语句用于声明变量
**变量声明的同时，可以赋值也可不赋值。**
- 注意1：
    - 变量名可以包含字母，数字，下划线和美元符号。
    - 变量名必须以字母开头
    - 变量名也可以以$和_开头（但一般不这么用）
    - 变量名是大小写敏感的（y和Y是不同的变量）
    - 保留字（如JavaScript关键字）不能作为变量名使用
- 注意2：
    - var会发生“变量提升”现象。

### let命令，用来声明变量。
**它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。**
- 注意1：
    - let不像var那样会发生“变量提升”现象。
- 注意2：
    - 只在声明所在的块级作用域内有效。
- 注意3：
    - let不允许在相同作用域内，重复声明同一个变量。
       ```js
        // 报错
        function() {
            let a = 10;
            var a = 1;
        }
        // 报错
        function() {
            let a = 10;
            let a = 1;
        }
        
        // 报错
        function func(arg) {
            let arg; 
        }
        // 不报错
        function func(arg) {
            {
                let arg; 
            }
        }
       ```     
    -因此，不能在函数内部重新声明参数。

### const声明一个只读的常量。
**一旦声明，常量的值就不能改变；且声明变量时，就必须立即初始化，不能留到以后赋值。**
- 注意1：
    - const的作用域与let命令相同：只在声明所在的块级作用域内有效。
- 注意2：
    - const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
- 注意3：
    - const声明的常量，也与let一样不可重复声明。
- 注意4：
    - 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。**const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变**，所以将一个对象声明为常量必须非常小心。   
    栗子1：
    ```js
    const foo = {};
    foo.prop = 123;

    foo.prop // 123

    foo = {}; // TypeError："foo" is read-only

    // 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
    ```
    栗子2：
    ```js
    const a = [];
    a.push('Hello'); // 可执行
    a.length = 0;    // 可执行
    a = ['Dave'];    // 报错
    
    // 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。
    ```

### 变量提升：把变量声明提升到当前执行环境的最顶端
```js
console.log(foo); // 输出undefined
console.log(bar); // 报错ReferenceError

var foo = 2;
let bar = 2;

// 上面代码中，由于var发生了“变量提升”现象，将foo的声明提升到了“console.log(foo)”前面，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。
// 变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。
```

---  

## 执行上下文、词法作用域
### 对于每个执行上下文，都有三个重要属性：
1. 变量对象(Variable object，VO)：是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。   

因为不同执行上下文下的变量对象稍有不同，所以来理一下全局上下文下的变量对象和函数上下文下的变量对象。   
- **全局上下文中的变量对象就是全局对象！**  

    - 可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。
    ```js
    console.log(this);
    ```
    - 全局对象是由 Object 构造函数实例化的一个对象。
    ```js
    console.log(this instanceof Object);
    ```
    - 预定义了一大堆函数和属性。
    ```js                   
    // 都能生效
    console.log(Math.random());
    console.log(this.Math.random());
    ```
    - 作为全局变量的宿主。
    ```js                  
    var a = 1;
    console.log(this.a);
    ```
    - 客户端 JavaScript 中，全局对象有 window 属性指向自身。
    ```js                   
    var a = 1;
    console.log(window.a);

    this.window.b = 2;
    console.log(this.b);
    ```
- **在函数上下文中，用活动对象来表示变量对象。**      
    - 活动对象(activation object, AO)和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。
    - 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

执行过程：执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：
- 1.进入执行上下文（当进入执行上下文时，这时候还没有执行代码）
    - 变量对象会包括：
        - 1）函数的所有形参 (如果是函数上下文)
            由名称和对应值组成的一个变量对象的属性被创建
            没有实参，属性值设为 undefined

        - 2）函数声明
            由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
            如果变量对象已经存在相同名称的属性，则完全替换这个属性

        - 3）变量声明
            由名称和对应值（undefined）组成一个变量对象的属性被创建；
            如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
举个栗子：
```js
function foo(a) {
    var b = 2;
    function c() {};
    var d = function() {};

    b = 3;
}
foo(1);

// 在进入执行上下文后，这时候的AO是：
AO = {
    arguments:{
        0:1,
        length:1
    },
    a:1,
    b:undefined,
    c:reference to function c() {},
    d:undefined
}
```           
注意：在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。
```js
console.log(foo); // 1
function foo() {
    console.log("foo"); // undefined
}
var foo = 1;

// 因为先处理函数声明，虽然变量名称相同，但不会覆盖函数。既然先处理函数，就执行函数内部的内容。
```

- 2.代码执行（在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值）
```js                
// 还是上面的栗子，当代码执行完之后，这时候的AO是：
AO = {
    arguments:{
        0:1,
        length:1
    },
    a:1,
    b:3,
    c:reference to function c() {},
    d:reference to FunctionExpression "d"
}
```
总结上述所说：
- 全局上下文的变量对象初始化是全局对象
- 函数上下文的变量对象初始化只包括 Arguments 对象
- 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
- 在代码执行阶段，会再次修改变量对象的属性值

2. 作用域链   
总结一下函数执行上下文中作用域链和变量对象的创建过程：
```js
var scope = "global scope";
function checkscope() {
    var scope2 = 'local scope';
    return scope2;
}
checkscope();
```

- 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]
```js
checkscope.[[scope]] = [
    globalContext.VO
];
```

- 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈
```js
ECSTACK = [
    checkscopeContext,
    globalContext
];
```
**当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，用个更专业一点的说法，就叫做"执行上下文(execution context)"。**   
接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？
- 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出
    - 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext

- 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链
```js
checkscopeContext = {
    Scope:checkscope.[[scope]],
}
```
Q：checkscope函数被创建时，保存到[[scope]]的作用域链 和 checkscope执行前的准备工作中，复制函数[[scope]]属性创建的作用域链有什么不同么？为什么会有两个作用域链？
    - A：checkscope函数创建的时候，保存的是根据词法所生成的作用域链，checkscope执行的时候，会复制这个作用域链，作为自己作用域链的初始化，然后根据环境生成变量对象，然后将这个变量对象，添加到这个复制的作用域链，这才完整的构建了自己的作用域链。
    - 至于为什么会有两个作用域链，是因为在函数创建的时候并不能确定最终的作用域的样子，为什么会采用复制的方式而不是直接修改呢？应该是因为函数会被调用很多次吧。

- 4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明
```js
checkscopeContext = {
    AO: {
        arguments:{
            length:0
        },
        scope2:undefined
    },
    Scope:checkscope.[[scope]],
}
```
- 5.第三步：将活动对象压入checkscope 作用域顶端
```js
checkscopeContext = {
    AO: {
        arguments:{
            length:0
        },
        scope2:undefined
    },
    Scope:[AO, [[Scope]]]
}
```
- 6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值
```js
checkscopeContext = {
    AO: {
        arguments:{
            length:0
        },
        scope2:'local scope'
    },
    Scope:[AO, [[Scope]]]
}
```
- 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出
```js
ECStack = [
    globalContext
];
```

3. this   
Reference 的构成，由三个组成部分，分别是：
- base value
    - base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。
- referenced name
    - referenced name 就是属性的名称。
- strict reference
```js
var foo = 1;

// 对应的 Reference 是：
var fooReference = {
    base:EnvironmentRecord,
    name:'foo',
    strict:false
};
```

```js
var foo = {
    bar:function() {
        return this;
    }
};
foo.bar(); // foo

// bar 对应的 Reference 是：
var BarReference = {
    base:foo,
    propertyName:'bar',
    strict:false
};
```
规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。
- GetBase
    - GetBase(V). Returns the base value component of the reference V.
    - 指的是：返回 reference 的 base value。
- IsPropertyReference
    - IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.
    - 指的是：如果 base value 是一个对象，就返回true。

从 Reference 类型获取对应值的方法： GetValue。
```js
var foo = 1;
var fooReference = {
    base:EnvironmentRecord,
    name:'foo',
    strict:false
};
GetValue(fooReference) // 1
```
- GetValue 返回对象属性真正的值，但是要注意：调用 GetValue，返回的将是具体的值，而不再是一个 Reference。这个很重要，这个很重要，这个很重要。

如何确定this的值：
- 1.计算 MemberExpression 的结果赋值给 ref
    - 什么是 MemberExpression？
        - PrimaryExpression // 原始表达式 
        - FunctionExpression // 函数定义表达式
        - MemberExpression [ Expression ] // 属性访问表达式
        - MemberExpression . IdentifierName // 属性访问表达式
        - new MemberExpression Arguments // 对象创建表达式
        - 例子：
        ```js
        function foo() {
            console.log(this)
        }
        foo(); // MemberExpression 是 foo

        function foo() {
            return function() {
                console.log(this)
            }
        }
        foo()(); // MemberExpression 是 foo()

        var foo = {
            bar:function() {
                return this;
            }
        }
        foo.bar(); // MemberExpression 是 foo.bar

        // 所以简单理解 MemberExpression 其实就是()左边的部分。
        ```

- 2.判断 ref 是不是一个 Reference 类型   
关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。
    - 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)
    - 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref)
    - 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined

    ```js
    var value = 1;
    var foo = {
        value:2,
        bar:function() {
            return this.value;
        }
    }

    // 示例1
    console.log( foo.bar() ); // 2
    // 示例2
    console.log( (foo.bar)() ); // 2
    // 示例3
    console.log( (foo.bar == foo.bar)() ); // 1
    // 示例4
    console.log( (false || foo.bar)() ); // 1
    // 示例5
    console.log( (foo.bar, foo.bar)() ); // 1
    ```
    - foo.bar()   
    在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？
        - **查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步：Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict。**   
        - 我们得知该表达式返回了一个 Reference 类型！
        - 根据之前的内容，我们知道该值为：

        ```js
        var Reference = {
            base:foo,
            name:'bar',
            strict:false
        };
        ```                   
        - 接下来按照 2.1 的判断流程走：该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？
            - 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。
            - base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。
            - 这个时候我们就可以确定 this 的值了：this = GetBase(ref)，
            - GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！

    - (foo.bar)()   
        - 示例 2 中，foo.bar被 () 包住，**查看规范 11.1.6 The Grouping Operator直接看结果部分：Return the result of evaluating Expression. This may be of type Reference.NOTE This algorithm does not apply GetValue to the result of evaluating Expression.**
        - 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。

    - (foo.bar = foo.bar)()   
        - 在示例 3 中，有赋值操作符，**查看规范 11.13.1 Simple Assignment ( = ):计算的第三步：Let rval be GetValue(rref).**
        - 因为使用了 GetValue，所以返回的值不是 Reference 类型，
        - 按照之前讲的判断逻辑：如果 ref 不是Reference，那么 this 的值为 undefined
        - this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。
            - 注意：所有例子都是在非严格模式下的结果。而严格模式下因为 this 返回 undefined，所以示例 3 会报错。

    - (false || foo.bar)()
        - 在示例 4 中，逻辑与算法，**查看规范 11.11 Binary Logical Operators：计算第二步：Let lval be GetValue(lref).**
        - 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined

    - (foo.bar, foo.bar)()
        - 在示例 5 中，逗号操作符，**查看规范11.14 Comma Operator ( , )，计算第二步：Call GetValue(lref).**
        - 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined

### 执行上下文栈和执行上下文的具体变化过程
例子：
```js
var scope = "global scope";
function checkscope() {
    var scope = "local scope";
    function f() {
        return scope;
    }
    return f();
}
checkscope();
```
1. 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈
```js
ECStack = [
    globalContext
];
```
2. 全局上下文初始化
```js
globalContext = {
    VO:[global],
    Scope:[globalContext.VO],
    this:globalContext.VO
}
```
- 初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]
```js      
checkscope.[[scope]] = [
    globalContext.VO
];
```
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈
```js        
ECStack = [
    checkscopeContext,
    globalContext
];
```
4. checkscope 函数执行上下文初始化：
- 1）复制函数 [[scope]] 属性创建作用域链，
- 2）用 arguments 创建活动对象，
- 3）初始化活动对象，即加入形参、函数声明、变量声明，
- 4）将活动对象压入 checkscope 作用域链顶端。
- 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]
```js       
checkscopeContext = {
    AO:{
        arguments:{
            length:0
        },
        scope:undefined,
        f:reference to function f() {}
    },
    Scope:[AO, globalContext.VO],
    this:undefined
}
```
5. 执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈
```js       
ECStack = [
    fContext,
    checkscopeContext,
    globalContext
];
```
6. f 函数执行上下文初始化, 以下跟第 4 步相同：
- 1）复制函数 [[scope]] 属性创建作用域链
- 2）用 arguments 创建活动对象
- 3）初始化活动对象，即加入形参、函数声明、变量声明
- 4）将活动对象压入 f 作用域链顶端
```js        
fContext = {
    AO:{
        arguments:{
            length:0
        }
    },
    Scope:[AO, checkscopeContext.AO, globalContext.VO],
    this:undefined
}
```
7. f 函数执行，沿着作用域链查找 scope 值，返回 scope 值
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出
```js        
ECStack = [
    checkscopeContext,
    globalContext
];
```
9. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
```js 
ECStack = {
    globalContext
};
```

### JavaScript 采用的是词法作用域（也就是静态作用域），函数的作用域在函数定义的时候就决定了；而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。
```js
var value = 1;
function foo() {
    console.log(value);
}
function bar() {
    var value = 2;
    foo();
}
bar();

// 结果是？？？
```
- 假设JavaScript采用静态作用域，让我们分析下执行过程：
    - 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。
- 假设JavaScript采用动态作用域，让我们分析下执行过程：
    - 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。
- 由于JavaScript采用的是静态作用域，所以这个例子的结果是 1。

---

## 原型链、作用域