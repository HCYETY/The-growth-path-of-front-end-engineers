# 浏览器的世界 <!-- omit in toc --> 
    目录
- [事件委托](#事件委托)
  - [事件](#事件)
  - [事件对象](#事件对象)
  - [事件流](#事件流)
  - [事件模型](#事件模型)
  - [事件委托](#事件委托-1)
- [浏览器存储的几个方法及其异同](#浏览器存储的几个方法及其异同)
  - [cookie](#cookie)
  - [](#)
- [重绘重排](#重绘重排)
  - [浏览器渲染页面的几个步骤：](#浏览器渲染页面的几个步骤)
  - [网页生成过程：](#网页生成过程)
  - [回流（reflow）](#回流reflow)
  - [重排](#重排)
  - [重绘（repaint）](#重绘repaint)
  - [减少回流和重绘的方法](#减少回流和重绘的方法)
  - [性能优化：](#性能优化)
- [浏览器的渲染机制](#浏览器的渲染机制)
  - [页面加载过程](#页面加载过程)
  - [线程和进程](#线程和进程)
  - [浏览器包含的进程：](#浏览器包含的进程)
  - [浏览器多进程的优势](#浏览器多进程的优势)
  - [浏览器内核（渲染进程）](#浏览器内核渲染进程)
  - [Browser主进程和浏览器内核（渲染进程）的通信过程](#browser主进程和浏览器内核渲染进程的通信过程)
  - [总结浏览器渲染流程](#总结浏览器渲染流程)
  - [浏览器如果渲染过程中遇到JS文件怎么处理](#浏览器如果渲染过程中遇到js文件怎么处理)
  - [浏览器渲染的图层](#浏览器渲染的图层)
  
========

     正文

========
## 事件委托
### 事件
事件是与浏览器交互的瞬间，如点击按钮，填写表格等，它是js与html之间交互的桥梁。
### 事件对象
当一个事件被触发时，会创建一个事件对象（Event Object），这个对象里面包含了与该事件相关的属性或者方法。该对象会作为第一个参数传递给监听函数。
- DOM事件模型中的事件对象常用属性：
    - type 事件类型
    - target 获取事件目标
    - stopPropageation() 阻止事件冒泡
    - preventDefault()阻止事件默认行为
- IE事件模型中的事件对象常用属性
    - type 事件类型
    - srcElement 获取事件目标
    - cancelBubble 阻止事件冒泡
        - true阻止；false不阻止；
    - returnValue 阻止事件默认行为
        - true不取消；false取消；
- 注意点：
    - 1、event代表事件的状态，例如触发event对象的元素，鼠标的位置及状态、按下的键等。
    - 2、event对象只在事件发生的过程中才有效
        - firefox里的event和IE中的不同，IE里的是全局变量，随时可用，firefox里的要用参数引导才能用，是运行时的临时变量。
        - 在IE/Opera中是window.event，在Firefox中是event;而事件的对象，在IE中是window.event.srcElement，在Firefox中是event.target，Opera中两者都可用。
### 事件流
两种方式：
- 事件冒泡：事件会从最内层的元素开始发生，一直向上传播，直到document对象。
    - 阻止冒泡：stopPropagation是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是不会阻止默认行为。
        ```js
        function stopBulle(e) {
            // 如果提供了事件对象，则这是个非IE浏览器
            if(e && e.stopPropagation) {
                e.stopPropagation();
            } else {
                // 我们需要使用 IE 的方式来取消事件冒泡
                window.event.cancelBubble = true;
            }
        }
        ```
    - 取消默认事件：preventDefault它也是事件对象的一个方法，作用是取消一个目标元素的默认行为
        ```js
        function stopDefault(e) {
            // 阻止默认行为
            if(e && e.preventDefault()) {
                e.preventDefault();
            } else {
                // IE 中阻止默认行为
                return false;
            }
        }
        ```
- 事件捕获：事件从最外层开始发生，直到最具体的元素。

区别：执行顺序不同

提问：当事件捕获和事件冒泡同时存在的情况下，事件又是如何触发的呢？
  - 对于非target节点，则先执行捕获再执行冒泡，对于target节点则先执行先注册的事件，无论冒泡还是捕获。
  - 先执行非target节点的捕获，然后根据注册顺序执行target节点的事件，然后再执行非target节点的冒泡。
### 事件模型
JavaScript事件模型主要分为3种：
- 原始事件模型
  - 这是一种被所有浏览器都支持的事件模型，对于原始事件而言，没有事件流，事件一旦发生将马上进行处理，有两种方式可以实现原始事件：
    ```html
    <!-- 1.在html代码种直接指定属性值： -->
    <button onclick= "handleCilck()" />  
    ```
    ```js
    // 2.在js代码中：
    document.getElementById('demo').onclick = function(){}
    ```
  - 优点：兼容所有浏览器。   
  - 缺点：1. 相同事件的监听函数只能绑定一个，后绑定的会覆盖掉前面的。<br>2.无法通过实现事件的捕获、委托等机制
- DOM2事件模型
    - W3C制定的事件模型种，一次事件的发生包含三个过程：
        - (1) 事件捕获阶段：事件从document一直向下传播到目标元素，依次检查经过的节点是否并定了事件监听函数，如果有则执行。
        - (2) 事件目标阶段：事件到达目标元素，触发目标元素的监听函数。
        - (3) 事件冒泡阶段：事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。
    - 事件绑定监听函数：addEventListener(eventType, handler, useCapture)
    - 事件移除监听函数：removeEventListener(eventType, handler, useCapture)
        - eventType指定事件类型（不要加on）    
        - handler是事件处理函数     
        - useCapture是一个boolean，设置false为冒泡，true为捕获
- IE事件模型
    - 有两个过程：
        - 事件处理阶段。事件达到目标元素，触发目标元素的监听函数。
        - 事件冒泡阶段。事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。
    - IE事件绑定监听函数的方式如下：aattachEvent(eventType, handler)
    - IE事件移除监听函数的方式如下：detachEvent(eventType, handler)
        - 参数说明：参数和addEventListener中的前两个参数一样，只是少了最后一个参数。
### 事件委托
把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。  
例子：实现效果：移入li、li变红，移出li、li变白，然后点击按钮可以向ul中添加一个li子节点
```html
<input type="button" id="btn" value="添加" />
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
下面采用一般的做法，但是新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去
```js
window.onload = function() {
    var oBtn = document.getElementById("btn");
    var oUl = document.getElementById("ul1");
    var aLi = oUl.getElementsByTagName('li');
    var num = 4;

    // 鼠标移入变红，移出变白
    for(var i = 0; i < aLi.length; i++) {
        aLi[i].onmouseover = function() {
            this.style.background = 'red';
        };
        aLi[i].onmouseout = function() {
            this.style.background = '#fff';
        }
    }

    // 添加新节点
    oBtn.onclick = function() {
        num++;
        var oLi.onclick = document.createElement('li');
        oLi.innerHTML = 111 * num;
        oUl.appendChild(oLi);
    };
}
```
虽然功能实现了，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，于是我们采用事件委托的方式优化一下
```js
window.onload = function() {
    var oBtn = document.getElementById("btn");
    var oUl = document.getElementById("ul1");
    var aLi = oUl.getElementsByTagName('li');
    var num = 4;

    function mHover() {
        // 鼠标移入变红，移出变白
        for(var i = 0; i < aLi.length; i++) {
            aLi[i].onmouseover = function() {
                this.style.background = 'red';
            };
            aLi[i].onmouseout = function() {
                this.style.background = '#fff';
            }
        }
    }
    mHover();

    // 添加新节点
    oBtn.onclick = function() {
        num++;
        var oLi.onclick = document.createElement('li');
        oLi.innerHTML = 111 * num;
        oUl.appendChild(oLi);
        mHover();
    };
}
```
用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。
```js
window.onload = function() {
    var oBtn = document.getElementById("btn");
    var oUl = document.getElementById("ul1");
    var aLi = oUl.getElementsByTagName('li');
    var num = 4;

    // 事件委托，添加的子元素也有事件
    oUl.onmouseover = function(ev) {
        var ev = ev || window.event;
        var target = ev.target || ev.srcElement;
        if(target.nodeName.toLowerCase() == 'li') {
            target.style.background = 'red';
        }
    };
    oUl.onmouseout = function(ev) {
        var ev = ev || window.event;
        var target = ev.target || ev.srcElement;
        if(target.nodeName.toLowerCase() == 'li') {
            target.style.background = '#fff';
        }
    };

    // 添加新节点
    oBtn.onclick = function() {
        num++;
        var oLi.onclick = document.createElement('li');
        oLi.innerHTML = 111 * num;
        oUl.appendChild(oLi);
    };
}
```
- 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。

---

## 浏览器存储的几个方法及其异同
### cookie
### 

---

## 重绘重排
### 浏览器渲染页面的几个步骤：
- 解析html生成DOM树，解析css，生成CSSOM树，将DOM树和CSSOM树结合，生成渲染树；
- 根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 回流
- 根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 重绘
- 最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面
### 网页生成过程：
HTML被HTML解析器解析成DOM 树 ![](img/15.png)
- 1、当服务器返回一个HTML文件给浏览器的时候，浏览器接受到的是一些字节数据。
- 2、然后浏览器根据HTTP响应中的编码方式（通过是UTF8），解析字节数据，得到一些字符。如果这个时候编码方式跟文件的字节编码不一致，便会出现乱码。所以我们通过使用<meta http-equiv="content-type"content="text/html;charset=utf-8">来告诉浏览器我们页面使用的是什么编码。
- 3、这个时候，浏览器再根据DTD中的对元素（标签）的定义，对这些接受到的字符进行语义化(token)。我们经常在html文件的第一行，定义<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">，这个DTD就是告诉浏览器，那些字符是有意义的，那些字符是无意义的。DTD常见的有严格、过渡、框架和HTML5三种。不同的DTD中，有不同的元素定义。比如过渡的DTD中就比严格的DTD中多出了<center>、<font>等等一些元素的定义，也就是说使用严格的DTD，即使你在你的HTML文件中使用了<center>，浏览器也会忽略掉的。所以也就有了一些人使用不同的DTD或者不使用DTD的时候，布局会明显不同的原因了
- 4、接着，浏览器再使用这些语义块(token)创建对象，形成一个个节点
- 5、然后HTML解析器就会从HTML文件的头部到尾部，一个个地遍历这些节点。当这些节点是普通节点的话，HTML解析器就会将这些节点加入到DOM树中。当这些节点是JS代码的话，HTML解析器就会将控制权交给JS解析器。如果这些节点是CSS代码的话，HTML解析器就会将控制权交给CSS解析器。不过，当外联的JS代码和CSS代码还没从服务器传到浏览器的时候，这个时候如果DOM树上有可视元素的话，浏览器通常会选择在这个时候，将一些内容提前渲染到屏幕上来。
- 6、当HTML解析器读到最后一个节点的时候，整个DOM树也构建完成了，这个时候就会触发domContentloaded事件。而很多JS库（像JQ）通常会在这个时候有所反应的。

    css则被css解析器解析成CSSOM 树
    结合DOM树和CSSOM树，生成一棵渲染树(Render Tree)
    生成布局（flow），即将所有渲染树的所有节点进行平面合成
    将布局绘制（paint）在屏幕上
    第四步和第五步是最耗时的部分，这两步合起来，就是渲染。而网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染
    重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)，或者只有第五个步(重新绘制)。
### 回流（reflow）
- 概念：指的是当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置。
    - 例：在css中对一个div修饰的样式中，使用了宽度50%，此时需要将50%转换为具体的像素，这个计算的过程，就是回流的过程。
- 容易造成回流的操作：
    - 1、布局流相关操作
        - 盒模型的相关操作会触发重新布局
        - 定位相关操作会触发重新布局
        - 浮动相关操作会触发重新布局
    - 2、改变节点内的内容
        - 改变节点的结构或其中的文本结构会触发重新布局
    - 3、css
        - width
        - height
        - padding
        - border
        - margin
        - position
        - top
        - left
        - bottom
        - right
        - float
        - clear
        - text-align
        - vertical-align
        - line-height
        - font-weight
        - font-size
        - font-family
        - overflow
        - white-space
### 重排
- 概念：重排也叫重构或者回流。它指的是界面中有部分元素的尺寸，布局发生了变化，那么就会导致发生变化的这部分呈现树重新构建（浏览器会使渲染树中受到影响的部分失效），这叫做浏览器的重排。
- 发生重排的情况：
    - 添加或删除可见的DOM元素
    - 元素位置改变
    - 元素本身的尺寸发生改变
    - 内容改变
    - 页面渲染器初始化
    - 浏览器窗口大小发生改变
每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时：
    offsetTop
    offsetLeft
    offsetWidth
    offsetHeight
    scrollTop
    scrollLeft
    scrollWidth
    scrollHeight
    clientTop
    clientLeft
    clientWidth
    clientHeight
    getComputedStyle()
    这些属性或方法都需要得到最新的布局信息，所以浏览器必须去回流执行。因此，在项目中，尽量避免使用上述属性或方法，如果非要使用的时候，也尽量将值缓存起来，而不是一直获取。

### 重绘（repaint）
- 完成重排后，浏览器会重新绘制受影响的部分到屏幕中。这个过程称为重绘。比如：改变元素的背景颜色、字体颜色等操作会造成重绘。
- 回流的过程在重绘的过程前面，所以回流一定会重绘，但重绘不一定会引起回流。
- 容易造成重绘操作的css：
    - color
    - border-style
    - border-radius
    - text-decoration
    - box-shadow
    - outline
    - background
### 减少回流和重绘的方法
- 合并样式修改，例：
    ```css
    var oDiv = document.querySelector('.box');
    oDiv.style.padding = '5px';
    oDiv.style.border = '1px solid #000';
    oDiv.style.margin = '5px';
    ```
    - 减少造成回流的次数，如果要给一个节点操作多个css属性，而每一个都会造成回流的话，尽量将多次操作合并成一个。操作div的3个css属性，分别是padding、border、margin，此时就可以考虑将多次操作合并为一次。
        - 方法一：使用style的cssText
            ```css
            oDiv.style.cssText = 'padding:5px; border:1px solid #000; margin:5px'
            ```
        - 方法二：将这几个样式定义给一个类名，然后给标签添加类名
            ```css
            <style>
                .pbm{
                    padding:5px;
                    border:1px solid #000;
                    margin:5px;
                }
            </style>
            <script>
                var oDiv = document.querySelector('.box');
                oDiv.classList.add('pbm');
            </script>
            ```
- 批量操作DOM
    - 在脱离标准流后，对元素进行的多次操作，不会触发回流，等操作完成后，再将元素放回标准流。
    - 脱离标准流的操作有3种：1.隐藏元素。2.使用文档碎片。3.拷贝节点
    - 例：下面对DOM节点的多次操作：每次给ul中新增一个li，每次都会触发回流
        ```js
        var data = [
            {
                id:1,
                name:"商品1",
            },
            {
                id:2,
                name:"商品2",
            },
            .......
        ];

        var oUl = document.querySelector("ul");
        for(var i = 0; i < data.length; i++) {
            var oLi = document.createElement("li");
            oLi.innerText = data[i].name;
            oUl.appendChild(oLi);
        }
        ```
        - 方法一：隐藏ul后，给ul添加节点，添加完成后再将ul显示。此时，在隐藏ul和显示ul的时候，触发了两次回流，给ul添加每个li的时候没有触发回流。
            ```js
            oUl.style.display = 'none';
            for(var i = 0; i < data.length; i++) {
                var oLi = document.createElement("li");
                oLi.innerText = data[i].name;
                oUl.appendChild(oLi);
            }
            oUl.style.display = 'block';
            ```
        - 方法二：创建文档碎片，将所有li先放在文档碎片中，等都放进去以后，再将文档碎片放在ul中
             ```js
            var fragment = document.createDocumentFragment();
            for(var i = 0; i < data.length; i++) {
                var oLi = document.createElement("li");
                oLi.innerText = data[i].name;
                fragment.appendChild(oLi);
            }
            oUl.appendChild(fragment);
            ```
        - 方法三：将ul拷贝一份，将所有li放在拷贝中，等都放进去以后，使用拷贝替换掉ul
           ```js
            var newUl = oUl.cloneNode(true);
            for(var i = 0; i < data.length; i++) {
                var oLi = document.createElement("li");
                oLi.innerText = data[i].name;
                newUl.appendChild(oLi);
            }
            oUl.parentElement.replaceChild(newUl, oUl);
            ```
- 避免多次触发布局
    - 对于页面中比较复杂的动画，尽量将元素设置为绝对定位，操作元素的定位属性，这样只有这一个元素会回流，如果不是定位的话，容易引起其父元素以及子元素的回流。
### 性能优化：
1. 分离读写操作，以下例子发生一次重排，因为所有的读操作放在写操作之后
```js
div.style.left = '10px';
div.style.top = '10px';
div.style.width = '20px';
div.style.height = '20px';
console.log(div.offsetLeft);
console.log(div.offsetTop);
console.log(div.offsetWidth);
console.log(div.offsetHeight);
```
2. 样式集中改变
3. 缓存布局信息
```js
// 强制刷新  触发两次重排
    div.style.left = div.offsetLeft +  + 'px';
    div.style.top = div.offsetTop +  + 'px';
// 缓存布局信息  读写分离
    var curLeft = div.offsetLeft;
    var curTop = div.offseTop;
    div.style.left = curLeft + 1 + 'px';
    div.style.Top = curTop + 1 + 'px';
```
4. position属性为absolute或fixed
- position属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响
5. 优化动画
- 可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小

---

## 浏览器的渲染机制
> 参考学习链接 -> [渲染页面：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)
### 页面加载过程
- 导航是加载web页面的第一步。它发生在以下情形：用户通过在地址栏输入一个URL、点击一个链接、提交表单或者是其他的行为
- 浏览器根据 DNS 服务器得到域名的 IP 地址
- 向这个 IP 的机器发送 HTTP 请求
- 服务器收到、处理并返回 HTTP 请求
- 浏览器得到返回内容
- 例如在浏览器输入 https://juejin.im/timeline，然后经过 DNS 解析， juejin.im对应的 IP 是 36.248.217.149（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。服务端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求
### 线程和进程
- 理解概念：
> 进程是一个工厂，工厂有它的独立资源 -- 工厂之间相互独立 -- 线程是工厂中的工人，多个工人协作完成任务 -- 工厂内有一个或多个工人 -- 工人之间共享空间。   
> 工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。
- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存）
- 线程是cpu调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）
- 浏览器是多进程的，每打开一个tab页，就相当于创建了一个独立的浏览器进程（进程内有自己的多线程）。
### 浏览器包含的进程：
- Browser进程：浏览器的主进程（负责协调，主控），只有一个，作用有：
    - 负责浏览器的界面显示，与用户交互，如前进，后退等
    - 负责各个页面的管理，创建和销毁其它进程
    - 将Rendered进程得到的内存中的Bitmap,绘制到用户界面上
        网络资源的管理，下载
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。
- GPU进程：最多一个，用于3D绘制等。
- 浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等
### 浏览器多进程的优势
- 避免单个page crash影响整个浏览器
- 避免第三方插件crash影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性
### 浏览器内核（渲染进程）
![](img/16.png)   
对于普通的前端操作来说，最重要的渲染进程：页面的渲染，js的执行，事件的循环等都在这个进程内执行。浏览器是多进程的，浏览器的渲染进程是多线程的；
- GUI渲染线程
    - 负责渲染浏览器界面，解析HTML,CSS,构建DOM树和RenderObject树，布局和绘制等。当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
    - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于冻结了）,GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
      - Q：为什么JS引擎线程 和 GUI渲染线程不能同时进行？
      - A1：由于JavaScript是可操作DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
      - A2：因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当JS引擎执行时GUI线程会被挂起。GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。
- JS引擎线程（JS内核）
    - 负责处理JavaScript脚本程序。（例如V8引擎）。
    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（render进程）中无论什么时候都只有一个JS线程在运行JS程序。
    - 注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
        - 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存在队列中，要等到JS引擎空闲后执行。然后由于巨量计算，所以JS引擎可能很久很久才能空闲，肯定就会感觉很卡。
- 事件触发线程
    - 该线程归属于浏览器而不是JS引擎，用来控制事件循环（可以理解成JS引擎自己都忙不过来，需要浏览器另开线程协助）。
    - 当JS引擎执行代码块如setTimeout时（也可来自浏览器内核的其它线程，如鼠标点击，AJAX异步请求等），会将对应任务添加到事件线程中。当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
    - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。
- 定时触发器线程
    - 传说中的`setTimeout`和`setInterval`所在的线程
    - 浏览器定时计数器并不是由JavaScript引擎计数的，（因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）。因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
    - 注意，W3C在HTML标准中规定，规定要求`setTimeout`中低于`4ms`的时间间隔定为`4ms`。
- 异步http请求线程
    - 在`XMLHttpRequest`在连接后是通过浏览器新型一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JavaScript引擎执行
- 总结：渲染进程如下：
    ![](img/17.png)
### Browser主进程和浏览器内核（渲染进程）的通信过程
打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开Tab页的渲染进程）；![](img/20.png)
- Browser主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过RendererHost接口传递给Render渲染进程
- Render渲染进程的Renderer接口收到消息，简单解释后，交给渲染线程GUI，然后开始渲染
- GUI渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser主进程获取资源和需要GPU进程来帮助渲染
- 当然可能会有JS线程操作DOM（这可能会造成回流并重绘）
- 最后Render渲染进程将结果传递给Browser主进程
- Browser主进程接收到结果并将结果绘制出来
### 总结浏览器渲染流程
![](img/18.png)
- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Render进程--浏览器渲染流程开始
- 浏览器渲染流程拿到内容后，渲染大概可以划分为：
    - 解析html建立dom树
    - 解析css构建render树（将css代码解析成树形的数据结构，然后结合dom合并成render树）
    - 布局render树（Layout/reflow）,负责各元素尺寸，位置的计算
    - 绘制render树（paint），绘制页面像素信息
    - 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite）,显示在屏幕上
- 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了。
    - 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。(譬如如果有async加载的脚本就不一定完成)
    - 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）
    - 所以，顺序是：DOMContentLoaded -> load
### 浏览器如果渲染过程中遇到JS文件怎么处理
- JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。 
- 如果想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为可以给 script 标签添加 defer 或者 async 属性。
    > async和defer的作用是什么？有什么区别?如下图中其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。![](img/19.png)

    ` 1.<script src="script.js"></script> `
    - 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
  
    ` 2.<script defer src="script.js"></script>(延迟执行)`
    - defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。
    - defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。
    - 
    `3）<script async src="script.js"></script> (异步下载)`
    - async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。
    - 在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载
### 浏览器渲染的图层
一般包含两大类：普通图层以及复合图层

复合图层，作用：一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。
- 1.普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）
- 2.absolute布局（fixed也一样），虽然可以脱离文档流，但它仍然属于默认复合层
    > absolute和硬件加速的区别
    - 就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）
    - 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）
- 3.可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）
    > 如何变成复合图层（硬件加速）：将元素变成一个复合图层，就是传说中的硬件加速技术
    - translate3d,translatez（最常用的方式）
    - opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
    - will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
    - `<video><iframe><canvas><webgl>`等元素
    - 其它，譬如以前的flash插件
    > 硬件加速时请使用index,防止浏览器默认给后续的元素创建复合层渲染
    - 具体的原理是：webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且relective或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能
    - 简单点理解，可以认为是一个隐式合成的概念：如果a是一个复合层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意
- 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒